{
    "name":  "v1_db_schema",
    "nodes":  [
                  {
                      "parameters":  {
                                         "httpMethod":  "POST",
                                         "path":  "v1/notion/db/schema",
                                         "responseMode":  "responseNode"
                                     },
                      "id":  "7403b315-1954-4038-8dba-1746b9bd9513",
                      "name":  "Webhook",
                      "type":  "n8n-nodes-base.webhook",
                      "typeVersion":  1,
                      "position":  [
                                       -200,
                                       0
                                   ]
                  },
                  {
                      "parameters":  {
                                         "mode":  "runOnceForAllItems",
                                         "jsCode":  "const executionId = this.getExecutionId ? this.getExecutionId() : Date.now().toString();\n\nfunction respond(statusCode, body) {\n  return [{ json: { httpStatus: statusCode, body } }];\n}\n\nfunction errorEnvelope(requestId, code, message, details) {\n  return {\n    request_id: requestId || null,\n    status: \u0027error\u0027,\n    correlation_id: executionId,\n    data: null,\n    error: { code, message, details: details || {} }\n  };\n}\n\nfunction okEnvelope(requestId, data) {\n  return {\n    request_id: requestId,\n    status: \u0027ok\u0027,\n    correlation_id: executionId,\n    data,\n    error: null\n  };\n}\n\nconst notionToken = $env.NOTION_API_KEY;\nif (!notionToken) {\n  return respond(500, errorEnvelope(null, \u0027config_error\u0027, \u0027NOTION_API_KEY is not set\u0027, {}));\n}\n\nconst baseUrl = \u0027https://api.notion.com/v1\u0027;\nconst notionHeaders = {\n  Authorization: `Bearer ${notionToken}`,\n  \u0027Notion-Version\u0027: \u00272022-06-28\u0027,\n  \u0027Content-Type\u0027: \u0027application/json\u0027\n};\n\nconst request = async (method, urlPath, bodyData) =\u003e {\n  const options = {\n    method,\n    url: `${baseUrl}${urlPath}`,\n    headers: notionHeaders,\n    json: true\n  };\n  if (bodyData) options.body = bodyData;\n  return this.helpers.httpRequest(options);\n};\n\nconst titleText = (text) =\u003e ({ title: [{ text: { content: text } }] });\nconst richText = (text) =\u003e ({ rich_text: [{ text: { content: text } }] });\n\nconst getTitleFromPage = (page) =\u003e {\n  if (!page || !page.properties) return \u0027\u0027;\n  const titleKey = Object.keys(page.properties).find((key) =\u003e page.properties[key].type === \u0027title\u0027);\n  if (!titleKey) return \u0027\u0027;\n  const titleArray = page.properties[titleKey].title || [];\n  return titleArray.map((t) =\u003e t.plain_text).join(\u0027\u0027);\n};\n\nconst getTitleFromDatabase = (db) =\u003e {\n  if (!db || !Array.isArray(db.title)) return \u0027\u0027;\n  return db.title.map((t) =\u003e t.plain_text).join(\u0027\u0027);\n};\n\nconst queryDatabase = async (dbId, filter) =\u003e {\n  return request(\u0027POST\u0027, `/databases/${dbId}/query`, { filter, page_size: 1 });\n};\n\nconst getPropertyText = (page, propName) =\u003e {\n  const prop = page.properties[propName];\n  if (!prop) return \u0027\u0027;\n  if (prop.type === \u0027rich_text\u0027) return (prop.rich_text || []).map((t) =\u003e t.plain_text).join(\u0027\u0027);\n  if (prop.type === \u0027title\u0027) return (prop.title || []).map((t) =\u003e t.plain_text).join(\u0027\u0027);\n  return \u0027\u0027;\n};\n\nconst findDatabaseByTitle = async (title) =\u003e {\n  const res = await request(\u0027POST\u0027, \u0027/search\u0027, {\n    query: title,\n    page_size: 10,\n    filter: { property: \u0027object\u0027, value: \u0027database\u0027 }\n  });\n  return (res.results || []).find((db) =\u003e getTitleFromDatabase(db) === title) || null;\n};\n\nconst findRegistryDbId = async () =\u003e {\n  const registryDb = await findDatabaseByTitle(\u0027OS Registry\u0027);\n  return registryDb ? registryDb.id : null;\n};\n\nconst findRegistryValue = async (registryDbId, key) =\u003e {\n  const res = await queryDatabase(registryDbId, {\n    property: \u0027Key\u0027,\n    title: { equals: key }\n  });\n  const page = (res.results || [])[0];\n  if (!page) return null;\n  return getPropertyText(page, \u0027Value\u0027);\n};\n\nconst resolveLedgerDbId = async (registryDbId) =\u003e {\n  if (!registryDbId) return null;\n  const ledgerId = await findRegistryValue(registryDbId, \u0027ledger_db_id\u0027);\n  if (ledgerId) return ledgerId;\n  const ledgerDb = await findDatabaseByTitle(\u0027Request Ledger\u0027);\n  return ledgerDb ? ledgerDb.id : null;\n};\n\nconst resolveDatabaseId = async (registryDbId, databaseKey) =\u003e {\n  if (!registryDbId) return null;\n  if (databaseKey === \u0027registry\u0027) return registryDbId;\n  if (databaseKey === \u0027request_ledger\u0027) return await resolveLedgerDbId(registryDbId);\n  const key = `${databaseKey}_db_id`;\n  const dbId = await findRegistryValue(registryDbId, key);\n  return dbId || null;\n};\n\nconst findLedgerEntry = async (ledgerDbId, idempotencyKey) =\u003e {\n  const res = await queryDatabase(ledgerDbId, {\n    property: \u0027Idempotency Key\u0027,\n    title: { equals: idempotencyKey }\n  });\n  return (res.results || [])[0] || null;\n};\n\nconst createLedgerEntry = async (ledgerDbId, data) =\u003e {\n  const properties = {\n    \u0027Idempotency Key\u0027: titleText(data.idempotencyKey),\n    \u0027Request ID\u0027: richText(data.requestId),\n    \u0027Endpoint\u0027: richText(data.endpoint),\n    \u0027Status\u0027: { select: { name: data.status } },\n    \u0027Result Object ID\u0027: richText(data.resultObjectId || \u0027\u0027),\n    \u0027Timestamp\u0027: { date: { start: data.timestamp } },\n    \u0027Raw Request\u0027: richText(data.rawRequest || \u0027\u0027)\n  };\n  return request(\u0027POST\u0027, \u0027/pages\u0027, {\n    parent: { database_id: ledgerDbId },\n    properties\n  });\n};\n\nconst getPage = async (pageId) =\u003e request(\u0027GET\u0027, `/pages/${pageId}`);\n\nconst headers = $json.headers || {};\nconst authHeader = (headers.authorization || headers.Authorization || \u0027\u0027).trim();\nconst bearerToken = $env.BOOTSTRAP_BEARER_TOKEN || $env.API_BEARER_TOKEN || \u0027\u0027;\n\nif (!bearerToken) {\n  return respond(500, errorEnvelope(null, \u0027config_error\u0027, \u0027No bearer token configured\u0027, {}));\n}\n\nconst expectedAuth = `Bearer ${bearerToken}`;\n\nif (authHeader !== expectedAuth) {\n  return respond(401, errorEnvelope(null, \u0027unauthorized\u0027, \u0027Invalid or missing Authorization header\u0027, {}));\n}\n\nconst body = .body;\nif (!body || typeof body !== \u0027object\u0027) {\n  return respond(400, errorEnvelope(null, \u0027invalid_request\u0027, \u0027Request body must be a JSON object\u0027, {}));\n}\n\nconst { request_id, actor, payload } = body;\nif (typeof request_id !== \u0027string\u0027 || typeof actor !== \u0027string\u0027 || typeof payload !== \u0027object\u0027 || payload === null) {\n  return respond(400, errorEnvelope(request_id, \u0027invalid_request\u0027, \u0027Missing or invalid request envelope fields\u0027, {}));\n}\n\nconst { database_key } = payload;\nif (typeof database_key !== \u0027string\u0027 || !database_key.trim()) {\n  return respond(400, errorEnvelope(request_id, \u0027invalid_request\u0027, \u0027payload.database_key is required\u0027, {}));\n}\n\ntry {\n  const registryDbId = await findRegistryDbId();\n  if (!registryDbId) {\n    return respond(500, errorEnvelope(request_id, \u0027registry_not_found\u0027, \u0027OS Registry database not found\u0027, {}));\n  }\n\n  const databaseId = await resolveDatabaseId(registryDbId, database_key);\n  if (!databaseId) {\n    return respond(400, errorEnvelope(request_id, \u0027invalid_request\u0027, \u0027Unknown database_key\u0027, { database_key }));\n  }\n\n  const db = await request(\u0027GET\u0027, /databases/);\n\n  return respond(200, okEnvelope(request_id, {\n    database_key,\n    database_id: databaseId,\n    database_name: getTitleFromDatabase(db),\n    properties: db.properties,\n    last_edited_time: db.last_edited_time\n  }));\n} catch (error) {\n  const message = error \u0026\u0026 error.message ? error.message : \u0027Schema fetch failed\u0027;\n  return respond(500, errorEnvelope(request_id, \u0027schema_failed\u0027, message, { stack: error \u0026\u0026 error.stack }));\n}"
                                     },
                      "id":  "b237df31-bff8-4e93-ab1b-0bca6d32bb8b",
                      "name":  "Handler",
                      "type":  "n8n-nodes-base.code",
                      "typeVersion":  2,
                      "position":  [
                                       40,
                                       0
                                   ]
                  },
                  {
                      "parameters":  {
                                         "responseCode":  "={{$json.httpStatus}}",
                                         "responseData":  "={{$json.body}}"
                                     },
                      "id":  "665db892-3fb2-4687-8d46-2dcfc58e1c5b",
                      "name":  "Respond",
                      "type":  "n8n-nodes-base.respondToWebhook",
                      "typeVersion":  1,
                      "position":  [
                                       300,
                                       0
                                   ]
                  }
              ],
    "connections":  {
                        "Webhook":  {
                                        "main":  [
                                                     {
                                                         "node":  "Handler",
                                                         "type":  "main",
                                                         "index":  0
                                                     }
                                                 ]
                                    },
                        "Handler":  {
                                        "main":  [
                                                     {
                                                         "node":  "Respond",
                                                         "type":  "main",
                                                         "index":  0
                                                     }
                                                 ]
                                    }
                    },
    "active":  false,
    "settings":  {

                 },
    "versionId":  "5a5f4c0f-165c-4842-af46-8ba60ec1d5de",
    "id":  "fbab28ad-aedf-431a-9691-66ab32a323ca",
    "tags":  [

             ]
}
