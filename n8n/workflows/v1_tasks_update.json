{
    "name":  "v1_tasks_update",
    "nodes":  [
                  {
                      "parameters":  {
                                         "httpMethod":  "POST",
                                         "path":  "v1/notion/tasks/update",
                                         "responseMode":  "responseNode"
                                     },
                      "id":  "e8dc626a-728d-4110-a69c-531d3f35ec6d",
                      "name":  "Webhook",
                      "type":  "n8n-nodes-base.webhook",
                      "typeVersion":  1,
                      "position":  [
                                       -200,
                                       0
                                   ]
                  },
                  {
                      "parameters":  {
                                         "mode":  "runOnceForAllItems",
                                         "jsCode":  "const executionId = this.getExecutionId ? this.getExecutionId() : Date.now().toString();\n\nfunction respond(statusCode, body) {\n  return [{ json: { httpStatus: statusCode, body } }];\n}\n\nfunction errorEnvelope(requestId, code, message, details) {\n  return {\n    request_id: requestId || null,\n    status: \u0027error\u0027,\n    correlation_id: executionId,\n    data: null,\n    error: { code, message, details: details || {} }\n  };\n}\n\nfunction okEnvelope(requestId, data) {\n  return {\n    request_id: requestId,\n    status: \u0027ok\u0027,\n    correlation_id: executionId,\n    data,\n    error: null\n  };\n}\n\nconst notionToken = $env.NOTION_API_KEY;\nif (!notionToken) {\n  return respond(500, errorEnvelope(null, \u0027config_error\u0027, \u0027NOTION_API_KEY is not set\u0027, {}));\n}\n\nconst baseUrl = \u0027https://api.notion.com/v1\u0027;\nconst notionHeaders = {\n  Authorization: `Bearer ${notionToken}`,\n  \u0027Notion-Version\u0027: \u00272022-06-28\u0027,\n  \u0027Content-Type\u0027: \u0027application/json\u0027\n};\n\nconst request = async (method, urlPath, bodyData) =\u003e {\n  const options = {\n    method,\n    url: `${baseUrl}${urlPath}`,\n    headers: notionHeaders,\n    json: true\n  };\n  if (bodyData) options.body = bodyData;\n  return this.helpers.httpRequest(options);\n};\n\nconst titleText = (text) =\u003e ({ title: [{ text: { content: text } }] });\nconst richText = (text) =\u003e ({ rich_text: [{ text: { content: text } }] });\n\nconst getTitleFromPage = (page) =\u003e {\n  if (!page || !page.properties) return \u0027\u0027;\n  const titleKey = Object.keys(page.properties).find((key) =\u003e page.properties[key].type === \u0027title\u0027);\n  if (!titleKey) return \u0027\u0027;\n  const titleArray = page.properties[titleKey].title || [];\n  return titleArray.map((t) =\u003e t.plain_text).join(\u0027\u0027);\n};\n\nconst getTitleFromDatabase = (db) =\u003e {\n  if (!db || !Array.isArray(db.title)) return \u0027\u0027;\n  return db.title.map((t) =\u003e t.plain_text).join(\u0027\u0027);\n};\n\nconst queryDatabase = async (dbId, filter) =\u003e {\n  return request(\u0027POST\u0027, `/databases/${dbId}/query`, { filter, page_size: 1 });\n};\n\nconst getPropertyText = (page, propName) =\u003e {\n  const prop = page.properties[propName];\n  if (!prop) return \u0027\u0027;\n  if (prop.type === \u0027rich_text\u0027) return (prop.rich_text || []).map((t) =\u003e t.plain_text).join(\u0027\u0027);\n  if (prop.type === \u0027title\u0027) return (prop.title || []).map((t) =\u003e t.plain_text).join(\u0027\u0027);\n  return \u0027\u0027;\n};\n\nconst findDatabaseByTitle = async (title) =\u003e {\n  const res = await request(\u0027POST\u0027, \u0027/search\u0027, {\n    query: title,\n    page_size: 10,\n    filter: { property: \u0027object\u0027, value: \u0027database\u0027 }\n  });\n  return (res.results || []).find((db) =\u003e getTitleFromDatabase(db) === title) || null;\n};\n\nconst findRegistryDbId = async () =\u003e {\n  const registryDb = await findDatabaseByTitle(\u0027OS Registry\u0027);\n  return registryDb ? registryDb.id : null;\n};\n\nconst findRegistryValue = async (registryDbId, key) =\u003e {\n  const res = await queryDatabase(registryDbId, {\n    property: \u0027Key\u0027,\n    title: { equals: key }\n  });\n  const page = (res.results || [])[0];\n  if (!page) return null;\n  return getPropertyText(page, \u0027Value\u0027);\n};\n\nconst resolveLedgerDbId = async (registryDbId) =\u003e {\n  if (!registryDbId) return null;\n  const ledgerId = await findRegistryValue(registryDbId, \u0027ledger_db_id\u0027);\n  if (ledgerId) return ledgerId;\n  const ledgerDb = await findDatabaseByTitle(\u0027Request Ledger\u0027);\n  return ledgerDb ? ledgerDb.id : null;\n};\n\nconst resolveDatabaseId = async (registryDbId, databaseKey) =\u003e {\n  if (!registryDbId) return null;\n  if (databaseKey === \u0027registry\u0027) return registryDbId;\n  if (databaseKey === \u0027request_ledger\u0027) return await resolveLedgerDbId(registryDbId);\n  const key = `${databaseKey}_db_id`;\n  const dbId = await findRegistryValue(registryDbId, key);\n  return dbId || null;\n};\n\nconst findLedgerEntry = async (ledgerDbId, idempotencyKey) =\u003e {\n  const res = await queryDatabase(ledgerDbId, {\n    property: \u0027Idempotency Key\u0027,\n    title: { equals: idempotencyKey }\n  });\n  return (res.results || [])[0] || null;\n};\n\nconst createLedgerEntry = async (ledgerDbId, data) =\u003e {\n  const properties = {\n    \u0027Idempotency Key\u0027: titleText(data.idempotencyKey),\n    \u0027Request ID\u0027: richText(data.requestId),\n    \u0027Endpoint\u0027: richText(data.endpoint),\n    \u0027Status\u0027: { select: { name: data.status } },\n    \u0027Result Object ID\u0027: richText(data.resultObjectId || \u0027\u0027),\n    \u0027Timestamp\u0027: { date: { start: data.timestamp } },\n    \u0027Raw Request\u0027: richText(data.rawRequest || \u0027\u0027)\n  };\n  return request(\u0027POST\u0027, \u0027/pages\u0027, {\n    parent: { database_id: ledgerDbId },\n    properties\n  });\n};\n\nconst getPage = async (pageId) =\u003e request(\u0027GET\u0027, `/pages/${pageId}`);\n\nconst headers = $json.headers || {};\nconst authHeader = (headers.authorization || headers.Authorization || \u0027\u0027).trim();\nconst bearerToken = $env.BOOTSTRAP_BEARER_TOKEN || $env.API_BEARER_TOKEN || \u0027\u0027;\n\nif (!bearerToken) {\n  return respond(500, errorEnvelope(null, \u0027config_error\u0027, \u0027No bearer token configured\u0027, {}));\n}\n\nconst expectedAuth = `Bearer ${bearerToken}`;\n\nif (authHeader !== expectedAuth) {\n  return respond(401, errorEnvelope(null, \u0027unauthorized\u0027, \u0027Invalid or missing Authorization header\u0027, {}));\n}\n\nconst body = .body;\nif (!body || typeof body !== \u0027object\u0027) {\n  return respond(400, errorEnvelope(null, \u0027invalid_request\u0027, \u0027Request body must be a JSON object\u0027, {}));\n}\n\nconst { request_id, idempotency_key, actor, payload } = body;\nif (typeof request_id !== \u0027string\u0027 || typeof idempotency_key !== \u0027string\u0027 || typeof actor !== \u0027string\u0027 || typeof payload !== \u0027object\u0027 || payload === null) {\n  return respond(400, errorEnvelope(request_id, \u0027invalid_request\u0027, \u0027Missing or invalid request envelope fields\u0027, {}));\n}\n\nconst { notion_page_id, patch } = payload;\nif (typeof notion_page_id !== \u0027string\u0027 || !notion_page_id.trim()) {\n  return respond(400, errorEnvelope(request_id, \u0027invalid_request\u0027, \u0027payload.notion_page_id is required\u0027, {}));\n}\n\nif (!patch || typeof patch !== \u0027object\u0027) {\n  return respond(400, errorEnvelope(request_id, \u0027invalid_request\u0027, \u0027payload.patch must be an object\u0027, {}));\n}\n\nconst hasPatch = [\u0027status\u0027, \u0027due\u0027, \u0027priority\u0027, \u0027notes_append\u0027].some((key) =\u003e Object.prototype.hasOwnProperty.call(patch, key));\nif (!hasPatch) {\n  return respond(400, errorEnvelope(request_id, \u0027invalid_request\u0027, \u0027patch must include at least one field\u0027, {}));\n}\n\ntry {\n  const registryDbId = await findRegistryDbId();\n  if (!registryDbId) {\n    return respond(500, errorEnvelope(request_id, \u0027registry_not_found\u0027, \u0027OS Registry database not found\u0027, {}));\n  }\n\n  const ledgerDbId = await resolveLedgerDbId(registryDbId);\n  if (!ledgerDbId) {\n    return respond(500, errorEnvelope(request_id, \u0027ledger_not_found\u0027, \u0027Request Ledger database not found\u0027, {}));\n  }\n\n  const existingLedger = await findLedgerEntry(ledgerDbId, idempotency_key);\n  if (existingLedger) {\n    const priorId = getPropertyText(existingLedger, \u0027Result Object ID\u0027) || notion_page_id;\n    const page = await getPage(priorId);\n    return respond(200, okEnvelope(request_id, {\n      updated: false,\n      notion_page_id: priorId,\n      notion_url: page.url\n    }));\n  }\n\n  let existingNotes = \u0027\u0027;\n  if (patch.notes_append) {\n    const page = await getPage(notion_page_id);\n    existingNotes = getPropertyText(page, \u0027Notes\u0027);\n  }\n\n  const properties = {};\n  if (patch.status) {\n    properties.Status = { select: { name: patch.status } };\n  }\n  if (patch.due) {\n    properties.Due = { date: { start: patch.due } };\n  }\n  if (patch.priority) {\n    properties.Priority = { select: { name: patch.priority } };\n  }\n  if (patch.notes_append) {\n    const combined = existingNotes ? ${existingNotes}\\n : patch.notes_append;\n    properties.Notes = richText(combined);\n  }\n\n  const updated = await request(\u0027PATCH\u0027, /pages/, { properties });\n\n  const nowIso = new Date().toISOString();\n  await createLedgerEntry(ledgerDbId, {\n    idempotencyKey: idempotency_key,\n    requestId: request_id,\n    endpoint: \u0027/v1/notion/tasks/update\u0027,\n    status: \u0027ok\u0027,\n    resultObjectId: notion_page_id,\n    timestamp: nowIso,\n    rawRequest: JSON.stringify(body)\n  });\n\n  return respond(200, okEnvelope(request_id, {\n    updated: true,\n    notion_page_id: updated.id,\n    notion_url: updated.url\n  }));\n} catch (error) {\n  const message = error \u0026\u0026 error.message ? error.message : \u0027Update task failed\u0027;\n  return respond(500, errorEnvelope(request_id, \u0027tasks_update_failed\u0027, message, { stack: error \u0026\u0026 error.stack }));\n}"
                                     },
                      "id":  "76f66ac2-5789-4d69-a8d8-d74b89b6d85a",
                      "name":  "Handler",
                      "type":  "n8n-nodes-base.code",
                      "typeVersion":  2,
                      "position":  [
                                       40,
                                       0
                                   ]
                  },
                  {
                      "parameters":  {
                                         "responseCode":  "={{$json.httpStatus}}",
                                         "responseData":  "={{$json.body}}"
                                     },
                      "id":  "e7cc5e26-b6db-488e-a99c-e36df4d991ad",
                      "name":  "Respond",
                      "type":  "n8n-nodes-base.respondToWebhook",
                      "typeVersion":  1,
                      "position":  [
                                       300,
                                       0
                                   ]
                  }
              ],
    "connections":  {
                        "Webhook":  {
                                        "main":  [
                                                     {
                                                         "node":  "Handler",
                                                         "type":  "main",
                                                         "index":  0
                                                     }
                                                 ]
                                    },
                        "Handler":  {
                                        "main":  [
                                                     {
                                                         "node":  "Respond",
                                                         "type":  "main",
                                                         "index":  0
                                                     }
                                                 ]
                                    }
                    },
    "active":  false,
    "settings":  {

                 },
    "versionId":  "3cfd9b36-1fbc-43a2-bf02-32183feae2c3",
    "id":  "7f9221b7-1ae0-40b0-bc8b-1cba50afd322",
    "tags":  [

             ]
}
